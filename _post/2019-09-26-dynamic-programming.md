---
layout:post
title:0-1背包问题
tags:动态规划
---

# 最优解
## 问题描述
> $n$个物品，它们有各自的重量和价值，现有给定承重量的背包，如何让背包里物品价值总和最大？

$eg:$

背包容量：$W=8$

|$i$（物品编号）|$w_{i}$（重量）|$v_{i}$（价值）|
|:---:|:---:|:---:|
|1|2|3|
|2|3|5|
|3|4|4|
|4|5|7|

定义：
$v_{i}$——第$i$个物品的价值；
$w_{i}$——第$i$个物品的重量；
$V(i,j)$——当前背包容量$j$，前$i$个物品最佳组合对应的价值。
## 动态规划递推式
1、**边界条件**，包容量或者物品数量为0，即$i=0orj=0$
> $$V(i,0)=V(0,j)=0$$

2、**递推条件1**，包的容量比商品$i$小，即`$(j<w_i)$，$i$无法装入，此时的价值与前$i-1$个的价值是一样的；
> $$V(i,j)=V(i-1,j)$$

3、**递推条件2**，包的容量比商品$i$小，即$(j{\ge}w_i)$，$i$可以放入，此时选择放$i$还是不放$i$
- （1）$i$物品不放入：
$$V(i,j)=V(i-1,j)$$
- （2）$i$物品放入：
$$V(i,j)=V(i-1,j_i)+v_i$$
> $$V(i,j)=max\{V(i-1,j),V(i-1,j-w_i)+v_i\}$$

## 填表

1、初始条件，$V(i,0)=V(0,j)=0$

|-|0|1|2|3|4|5|6|7|8|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|0|0|0|0|0|0
|1|0|
|2|0|
|3|0|
|4|0|

2、按递推条件

|-|0|1|2|3|4|5|6|7|8|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|0|0|0|0|0|0
|1|0|0|3|3|3|3|3|3|3|
|2|0|0|3|5|5|8|8|8|8|
|3|0|0|3|5|5|8|8|9|9|
|4|0|0|3|5|5|8|8|10|12|

-  $i=1,j=1,w_1=2,v_1=3,有j<w(1),故V(1,1)=V(0,1)=0;$
-  $i=1,j=2,w_1=2,v_1=3,有j=w(1),故V(1,2)=max\{V(0,2),V(0,2-w_1)+v_1\}=max\{V(0,2),V(0,0)+v_1\}=max\{0,3\}=3;$
-  $...$
-  $i=4,j=8,w_1=5,v_1=7,有j>w(1),故V(4,8)=max\{V(3,8),V(3,8-w_1)+v_1\}=max\{V(3,8),V(3,3)+v_1\}=max\{9,10\}=10$

## 代码
[cpp实现](../src/cpp/0-1bag.cpp)

```
int** bag(const int W, const int num, int w[], int v[]) {
    int **dp = new int*[num];   
    for (int i = 0; i < num ; ++i) {
        dp[i] = new int[W + 1];
    }
    for (int i = 0; i < num; ++i) {
        for (int j = 0; j < W + 1; ++j) {
            dp[i][j] = 0;    //必须先分配初值，放在下面for下赋值会报读取内存失败的错误
        }
    }
	
    for (int i = 1; i < num; ++i) {
        for (int j = 1; j < W + 1; ++j) {
            if (w[i] > j)
                dp[i][j] = dp[i - 1][j];
            else
                dp[i][j] = max( dp[i - 1][j],dp[i - 1][j - w[i]] + v[i] );			
        }
    }
    return dp;
};

int main() {
    const int W = 8;
    int w[5] = {0,2,3,4,5 };
    int v[5] = { 0,3,5,4,6 };
    int num = 5;
    int **dp = bag(W, num, w, v);
    for (int i = 0; i < num; ++i) {
        for (int j = 0; j < W + 1; ++j) {
            cout << dp[i][j] << " ";
        }
        cout << endl;
    }
    findWhat(dp, w, v, num-1, W);

    system("pause");
    return 0;
}
```
# 最优解回溯
## 回溯方式
- 1、$V(i,j)=V(i-1,j)$时，说明没有选择第$i$个商品，则返回到$V(i-1,j)$；
- 2、$V(i,j)=V(i-1,j-w_i)+v_i$，说明选择了第$i$个商品，该商品是最优解组成的一部分，返回到$V(i-1,j-w_i)$；
- 3、$i=0$时结束。
## 代码

```
void findWhat(int** &dp, int w[], int v[], int i, int j) {
    if (i > 0) {
        if (dp[i][j] == dp[i - 1][j]) {
            findWhat(dp, w, v, i - 1, j);
        }
        else if(j>=w[i]&&dp[i][j]==dp[i-1][j-w[i]]+v[i]){
            cout << i << " ";
            findWhat(dp, w, v, i - 1, j - w[i]);
        }
    }
}
```

