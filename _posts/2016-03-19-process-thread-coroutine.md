---
layout: post
title: 进程，线程，协程 学习比较
tags: thread coroutine
---

###参考
* [廖雪峰协程介绍](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000)
* [UC 技术博客-协程实现基础](http://tech.uc.cn/?p=1055)
* [进程线程协程和goroutine那些事](http://www.cnblogs.com/shenguanpu/archive/2013/05/05/3060616.html)
* [sf上七牛云介绍python中进程线程协程相关技术](https://segmentfault.com/a/1190000001813992#articleHeader28)
* [赖勇浩 协程介绍](http://blog.csdn.net/gzlaiyonghao/article/details/5397038)

###相关知识汇总
```
协程可以认为是一种**用户态轻量级的线程**，操作系统是感知不到协程的存在的。
与系统提供的线程不同点是， 它需要主动让出CPU时间，而不是由系统进行调度，
即控制权在程序员手上,只需要进行用户态上下文切换。

既然看成是用户态线程，那必然要求程序员自己进行各个协程的调度，
这样就必须提供一种机制,供编写协程的人将当前协程挂起，即保存协程运行场景的一些数据，
调度器在其他协程挂起时再将此协程运行场景的数据恢复，以便继续运行。
这里我们将协程运行场景的数据称为上下文。

在linux里，有getcontext和swapcontext等接口来获取当前的上下文数据和切换上下文。
那如果没有提供相应的接口，又该如何来实现呢？

其实说到底，保存下上文数据，不外乎就是保存下当前运行的栈空间的数据，
还有cpu各个寄存器相应的值。只要我们能够将其保存下来，在特定的时刻恢复回去就可以了。
```

###线程和协程的区别：

> 一旦创建完线程，你就无法决定他什么时候获得时间片，什么时候让出时间片了，你把它交给了内核。
> 而协程编写者可以有一是可控的切换时机，二是很小的切换代价。
> 从操作系统有没有调度权上看，协程就是因为不需要进行内核态的切换，所以会使用它，
> 赖勇浩和dccmx 这个定义我觉得相对准确  **协程是用户态的轻量级的线程**。

###进程、线程、协程比较
* 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
* 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。
* 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。

> 进程和其他两个的区别还是很明显的。

协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，

同时，协程也失去了标准线程使用多CPU的能力, 但是可用通过多个(进程+多协程)模式来充分利用多CPU。

###进程与线程的比较

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。
进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，
而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，
一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮 ，
但在进程切换时，耗费资源较大，效率要差一些。
但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程


